= JEP-0000: Jakarta EE 9 Migration
:toc: preamble
:toclevels: 3
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

.Metadata
[cols="1h,1"]
|===
| JEP
| 0000

| Title
| Jakarta EE 9 Migration

| Sponsor
| link:https://github.com/basil[Basil Crow]

| Status
| Draft :speech_balloon:

| Type
| Informational

| Created
| Date 2024-03-19

| BDFL-Delegate
| TBD

//
//
// Uncomment if there is an associated placeholder JIRA issue.
//| JIRA
//| https://issues.jenkins-ci.org/browse/JENKINS-nnnnn[JENKINS-nnnnn]
//
//
// Uncomment if discussion will occur in forum other than jenkinsci-dev@ mailing list.
//| Discussions-To
//| Link to where discussion and final status announcement will occur
//
//
// Uncomment if this JEP depends on one or more other JEPs.
//| Requires
//| JEP-NUMBER, JEP-NUMBER...
//
//
// Uncomment and fill if this JEP is rendered obsolete by a later JEP
//| Superseded-By
//| JEP-NUMBER
//
//
// Uncomment when this JEP status is set to Accepted, Rejected or Withdrawn.
//| Resolution
//| Link to relevant post in the jenkinsci-dev@ mailing list archives

|===

== Abstract

Servlet API 4.x, which delivers `javax.servlet` packages, is replaced with the latest version of Servlet API (6.x at the time of this writing), which delivers `jakarta.servlet` packages.
Jetty 10.x, which only supports `javax.servlet` packages, is replaced with the latest version of Jetty (12.x at the time of this writing), which supports `jakarta.servlet` packages.
Spring Security and its dependency Spring Framework 5.x, which only support `javax.servlet` packages, are replaced with the latest versions (6.x at the time of this writing), which support `jakarta.servlet` packages and require Java 17 or newer.
Commons FileUpload 1.x, which only supports `javax.servlet` packages, is replaced with the latest version (2.x at the time of this writing), which supports `jakarta.servlet` packages.

Jenkins core and core components, including the Jenkins test harness (JTH) are fully migrated to the above releases and `jakarta.servlet` packages.
For compatibility, bridge methods are added to offer a modicum of backward compatibility for the many plugins referring to the old packages.
Key plugins are patched when necessary to ensure the use of the new packages in the (rare) absence of bridge methods.

== Motivation

=== Security updates

Staying on an old version of Spring Security places the project at risk of not receiving upstream security updates.
In the case of exploitable vulnerabilities, this requires the project to develop or backport security updates independently,
which is significantly more effort than applying an upstream security update.
Many security-conscious organizations using, or planning to use, Jenkins run off-the-shelf security scanners to look for known vulnerabilities.
Regardless of whether or not a vulnerability is exploitable, such scanners will flag old versions of libraries as susceptible to exploitation,
and it is time-consuming for the https://www.jenkins.io/security/team/[security team] to respond to purported security reports and for users to justify exemptions from policy to use Jenkins anyway.

=== Technical debt

Staying on an old version of Spring Security introduces a maintenance burden for Jenkins developers.
The rest of the Java ecosystem will increasingly shift its focus to `jakarta.servlet` packages,
in part catalyzed by the Spring project's schedule.
As this shift occurs, unmaintainable workarounds will increasingly be needed to retain the old version of Spring Security.

== Reasoning

=== Status quo

Continuing to use Servlet API 4.x indefinitely does not seem sustainable.
The last 5.x releases of Spring Security and its dependency Spring Framework will be published in https://spring.io/blog/2024/03/01/support-timeline-announcement-for-spring-framework-6-0-x-and-5-3-x[August 2024, with the official end of open source support on August 31, 2024].
The subsequent 6.x releases require both `jakarta.servlet` packages and Java 17 or newer.
The use of `jakarta.servlet` packages in turn requires upgrading Jetty and Commons FileUpload.
Failure to upgrade to these releases puts the project at risk of not receiving upstream bug fixes and security updates.

On its own, an upgrade of all of the above libraries would severely break compatibility with plugins throughout the Jenkins ecosystem.
Plugins that link against the old `javax.servlet` packages would stop working when core is upgraded to `jakarta.servlet` packages, motivating the need for a migration plan.

=== Prerequisites

The actions outlined in this document assume that Jenkins requires Java 17 or newer.
Combining a Java upgrade with the migration outlined in this document would conflate two separate but related issues and make the document more difficult to read.
Furthermore, Java upgrades are a routine process not tied to this migration and therefore deserve a separate Jenkins Enhancement Proposal (JEP).
Therefore, this document assumes that a routine migration to Java 17 has already taken place and only describes the steps required after that to migrate to `jakarta.servlet` packages.

=== High-level solution

At a high level, perform a classic two-phase migration.
In the first phase, switch the implementation to `jakarta.servlet` packages and begin providing support for plugins that link against `jakarta.servlet` packages while retaining support for plugins that link against `javax.servlet` packages;
in other words, add a new capability and deprecate the old capability.
In particular, implement support for the deprecated old capability in terms of the new capability through a compatibility subsystem; namely, bridge methods.
In the short term, plugin consumers that rely on the old capability will continue to work through the compatibility subsystem.
In the medium term, migrate the plugins in the Bill of Materials (BOM) to the new capability, mitigating both risk of regression and technical debt.
In the long term, migrate the long tail of plugins to the new capability, completing the migration.

Why follow such a phased approach?
Not developing a compatibility subsystem would be too disruptive of a change.
Almost all plugins would need to be upgraded in lockstep with core,
which would be prohibitively difficult to coordinate from the perspective of both maintainers and end users.

Implementing the compatibility subsystem in terms of the new functionality decreases technical debt.
Compatibility subsystems that retain the old interface and the old implementation require maintenance of both the old implementation and new.
By implementing the old interface in terms of the new implementation, this design reduces the maintenance burden from two implementations to one.

Delaying the migration of plugins to the new interface increases both risk of regression and technical debt.
It increases risk of regression because the compatibility subsystem is necessarily incomplete,
and automated tests might not expose all functionality that is not covered by the compatibility subsystem.
It increases technical debt because because the migration will have to be done eventually,
and if it is not done in a timely fashion it will likely delay a future project.
As such, it is important to migrate the plugins in the BOM away from the compatibility subsystem in a timely fashion,
ideally before the change ships in a Long Term Support (LTS) release.

The same concerns apply to the long tail of plugins not in the BOM, but with less urgency due to lower adoption rates.
However, this does not imply that the migration can be postponed indefinitely, as waiting too long can burden developers working on unrelated changes.
We suggest performing the long tail migration, defined conservatively as anything with over 10,000 installations, within a maximum of nine (9) months after the changes have been delivered in an LTS release.

== Phase 1: Kickoff

Fully migrate Jenkins core and core components, including the Jenkins test harness (JTH), to the latest upstream releases and `jakarta.servlet` packages.
Add bridge methods to offer backward compatibility for the vast majority of method calls used by existing plugins.
For the handful of method calls that cannot be easily bridged, prepare plugins in advance to use the new `jakarta.servlet` packages,
noting that this implies selecting a weekly release as the core baseline.
Get a successful PCT test run with all of the above updates, giving us confidence to release to production.
Release a core weekly containing all of the above changes, and release the plugins prepared above at the same time.
Document in the core release notes that the plugins prepared above must be upgraded in lockstep with core.
Congratulations! You have now added a new capability to a Jenkins weekly without breaking compatibility.
You have also kicked off a migration that must be completed soon.

== Phase 2: Top 250 plugins

The majority of Jenkins plugins will now be running successfully through the compatibility subsystem.

== Phase 3: Long tail plugins

Provide
For compatibility, bridge methods are added to offer a modicum of backward compatibility for the many plugins referring to the old packages.
Key plugins are patched when necessary to ensure the use of the new packages in the (rare) absence of bridge methods.





=== Upgrade Spring Security but not Jakarta Servlet

Version 6.x of Spring Security and its dependency Spring Framework officially requires `jakarta.servlet` imports,
but it is unclear how much of the portion of Spring Security which references Servlet API types we actually use.
It might be possible to continue to use `javax.servlet` generally and in the meantime only bridge to `jakarta.servlet` for the more limited needs of the specific functionality we consume,
which likely only call a handful of routine methods like getting/setting headers and session attributes.

This is a short-term approach that would address the security portion of the Motivation section without addressing the technical debt portion.
On the contrary, it is an example of the "unmaintainable workarounds" described in that section.

=== 






== Reasoning




[TIP]
====
Explain why particular design decisions were made.
Describe alternate designs that were considered and related work. For example, how the feature is supported in other systems.
Provide evidence of consensus within the community and discuss important objections or concerns raised during discussion.

* Use sub-headings to organize this section for ease of readability.
* Provide a clear description of the cause of the problem.
* Provide a clear description of the high-level solution you have chosen and how it addresses the cause of the problem.
* If there were other possible solutions that you considered and rejected, mention those along with the corresponding reasoning.
* Do not describe implementation details; these should go into the Specification section instead.
* Do not talk about history or why this needs to be done - that is part of Motivation section.
====

== Specification

* Upgrade Jetty to the latest version in Winstone, Stapler, core, and the Jenkins test harness.
* Upgrade the versions of `jakarta.servlet.jsp.jstl-api`, `jakarta.servlet-api`, and `jakarta.servlet.jsp-api` in Jelly, Stapler, and core to match those of the aforementioned Jetty version.
* Upgrade Commons FileUpload to the latest version in Stapler and core.
* Upgrade Spring Framework and Spring Security to the latest versions in core.
* Upgrade Winstone to the latest versions in core.
* Upgrade the Jenkins test harness to the latest version in core.

[TIP]
====
Provide a detailed specification of what is being proposed.
Be as technical and detailed as needed to allow new or existing Jenkins developers
to reasonably understand the scope/impact of an implementation.

* Use present tense - describe what the proposal "does" (as if it were already done), not what it will do.
* Do not discuss alternative designs that were rejected - those belong in the Reasoning section.
* Avoid in-depth discussion or justification of design choices - that belongs in the Reasoning section.
====

== Backwards Compatibility

[TIP]
====
Describe any incompatibilities and their severity.
Describe how the JEP proposes to deal with these incompatibilities.

If there are no backwards compatibility concerns, this section may simply say:
There are no backwards compatibility concerns related to this proposal.
====

== Migration

[TIP]
====
Describe the work that needs to be done, if any, to adapt consumers to the proposed change.

Conventional wisdom is that at least three consumers should exist to validate the design of an API;
with only one consumer the API probably won't support another consumer,
and with two consumers the API will probably only support more consumers with difficulty
(see "The Rule of Threes" in Will Tracz's _Confessions of a Used Program Salesman,_ Addison-Wesley, 1995).

Completing this section of the JEP involves quantifying
the number of consumers that need to be adapted (the cost)
and the expected value after adapting these consumers (the benefit).
Since the Jenkins project has thousands of individual components,
attempting to adapt too many consumers tends to reach a point of diminishing returns.
On the other hand, adapting too few consumers risks not only violating the Rule of Threes
but also introducing technical debt to the project in the form of incomplete migrations.
These incomplete migrations can in turn significantly delay the delivery of future JEPs.

In describing the work that needs to be done to adapt consumers,
this section should include a cost-benefit analysis and describe a rational approach to the migration
that balances short-term deliverability against long-term maintainability.

Typically, migrations should cover a large portion of the top 200 plugins and/or the plugins in the Bill of Materials (BOM),
as the overall health of the Jenkins project is contingent on the health of these popular plugins to a large degree.
When in doubt, begin the cost-benefit analysis with this general example
and then determine if the calculus needs to be adjusted for the particular case in question.

While not all consumers need to be fully migrated,
the scope of the migration does need to be fully quantified
in order for the design to stand on its own.

If consumers do not need to be adapted to this change, this section may simply say:
There are no migration concerns related to this proposal.
====

== Security

[TIP]
====
Describe the security impact of this proposal.
Outline what was done to identify and evaluate security issues,
discuss potential security issues and how they are mitigated or prevented,
and detail how the JEP interacts with existing elements in Jenkins, such as permissions, authentication, authorization, etc.

If this proposal will have no impact on security, this section may simply say:
There are no security risks related to this proposal.
====

== Infrastructure Requirements

[TIP]
====
Describe any impact on the Jenkins project infrastructure.

Include any additions or changes, interactions with existing components,
potential instabilities, service-level agreements,
and responsibilities for continuing maintenance.
Explain the scope of infrastructure changes with sufficient detail
to allow initial and on-going cost (in both time and money) to be estimated.

If this proposal will have no impact on infrastructure, this section may simply say:
There are no new infrastructure requirements related to this proposal.
====

== Testing

[TIP]
====
If the JEP involves any kind of behavioral change to code
(whether in a Jenkins product or backend infrastructure),
give a summary of how its correctness (and, if applicable, compatibility, security, etc.) will be tested.

In the preferred case that automated tests will be developed to cover all significant changes, simply give a short summary of the nature of these tests.

If some or all of the changes will require human interaction to verify them, explain why automated tests are considered impractical.
Then, summarize what kinds of test cases might be required: user scenarios with action steps and expected outcomes.
Detail whether behavior might be different based on the platform (operating system, servlet container, web browser, etc.)?
Are there foreseeable interactions between different permissible versions of components (Jenkins core, plugins, etc.)?
Does this change require that any special tools, proprietary software, or online service accounts to exercise a related code path (e.g., Active Directory server, GitHub login, etc.)?
When will you complete testing relative to merging code changes, and might retesting be required if other changes are made to this area in the future?

If this proposal requires no testing, this section may simply say:
There are no testing issues related to this proposal.
====

== Prototype Implementation

[TIP]
====
Link to any open source reference implementation of code changes for this proposal.
The implementation need not be completed before the JEP is
link:https://github.com/jenkinsci/jep/tree/master/jep/1#accepted[accepted],
but must be completed before any JEP is given
"link:https://github.com/jenkinsci/jep/tree/master/jep/1#final[Final]" status.

JEPs which will not include code changes may omit this section.
====

== Work Estimates

[TIP]
====
Provide a clear description of the high-level tasks needed to productize the prototype implementation.
Ideally these tasks would be turned into work items in an issue tracking system (ITS) like Jira or GitHub Issues.
As a general rule, it should be possible to complete each task within 1-3 days;
if a task takes a week or longer, it has not been broken down with enough granularity.
If these tasks are not obvious, then the prototype is not complete enough.
Also describe the general roles needed to perform these tasks.
For example, is the task well-suited to a new contributor,
or does the task require advanced experience in the Jenkins project that demands a seasoned expert?
Perhaps the task is well-suited to contributors with an affinity for e.g. frontend development, security, or DevOps.
Finally, describe the nature of the work in relation to time:
can these tasks be picked up in parallel by any interested volunteers,
or do they need to be done in some specific order?
Do any tasks depend on other tasks in a way that would serialize the implementation of the project?

JEPs that do not include a prototype implementation may omit this section.
====

== References

[TIP]
====
Provide links to any related documents.
This will include links to discussions on the mailing list, pull requests, and meeting notes.
====
